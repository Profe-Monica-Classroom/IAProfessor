# -*- coding: utf-8 -*-
"""busqueda.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c717Ay0_e35KyxyVMuUU2PQJC-ApU4_B
"""

import tensorflow as tf
import numpy as np

#DEFINIR EL ESPACIO DE BUSQUEDA DEL PROBLEMA
#UTILIZAMOS UN MAPA CON 10FILAS Y 10COLUMNAS

mapa = np.zeros ((10, 10))

#DEFINIMOS POSICION Y INICIO DEL CARRO
start =(0, 0)
goal = (9, 9)

#FUNCION PARA EXPANDIR LOS NODOS Y AGG LOS SUCESORES A LA COLA
def expandir_nodo (nodo, mapa):
  sucesores = []
  
  #HACIA ARRIBA
  if nodo [0] > 0 and mapa [nodo[0]-1, nodo[1]] !=1:
    sucesores.append((nodo[0]-1, nodo[1]))
  #HACIA ABAJO
  if nodo [0] < mapa.shape[0] - 1 and mapa[nodo[0] + 1, nodo [1]] !=1:
    sucesores.append((nodo[0] + 1, nodo[1]))
  #HACIA LA IZQUIERDA
  if nodo [0] > 0 and mapa [nodo[0], nodo[1]-1] !=1:
    sucesores.append((nodo[0], nodo[1]-1))
  #HACIA LA DERECHA
  if nodo [0] < mapa.shape[0] - 1 and mapa[nodo[0], nodo [1] + 1] !=1:
    sucesores.append((nodo[0], nodo[1]+1))

  return sucesores

#DEFINIMOS LA COLA PARA LA BUSQUEDA POR ANCHURA 
cola = [start]

#DEFINIMOS DONDE SE ALMACENARA LOS NODOS PADRES
padres ={start: None}

#REEALIZAR LA BUSQUEDA POR ANCHURA 
while cola:
  nodo_actual1 =cola.pop(0)
  if nodo_actual1 == goal:
    break
    for sucesor in expandir_nodo(nodo_actual1, mapa):
      if sucesor not in padres:
        cola.append(sucesor)
        padres[sucesor] = nodo_actual1

#RECUPERAR EL CAMINO OPTIMO A TRAVES DE LOS NODOS PADRES
camino_optimo =[]
nodo_actual =goal
while nodo_actual is not None:
  camino_optimo.append(nodo_actual1)
  nodo_actual = padres[nodo_actual1]
camino_optimo.reverse()

print(camino_optimo)

#software

import tensorflow as tf 

# Definir el modelo de red neuronal
 model = tf.keras.Sequential ([ 
     tf.keras.layers.Dense(16, input_shape=(2,), activation='relu'), 
     tf.keras.layers.Dense(8, activation='relu'), 
     tf.keras.layers.Dense(4, activation='softmax') 
     ]) 
 # Compilar el modelo 
 model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy']) 

 # Entrenar el modelo con datos de entrenamiento 
 model.fit(X_train, y_train, epochs=10, batch_size=32) 

 # Evaluar el modelo con datos de prueba 
 model.evaluate(X_test, y_test) 
 
 # Usar el modelo para predecir el control de los motores 
 prediction = model.predict(sensor_data) 
 
 # Convertir la salida de la red neuronal a los valores de control de los motores 
 left_motor_speed = prediction[0][0] 
 right_motor_speed = prediction[0][1] 
 
 # Asignar los valores de velocidad a los motores 
 set_motor_speed(left_motor_speed, right_motor_speed)